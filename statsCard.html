<<<<<<< HEAD
<!-- Stats Cards Component - Grid Layout -->

<!-- Utilization Card with Circle -->
<div class="card utilizado">
    <div class="percentage-circle">
        <div class="percentage-text" id="utilizacion-percentage">--</div>
    </div>
    <div class="card-label">% Utilizado</div>
    <div class="card-loading hidden">
        <div class="card-loader"></div>
    </div>
</div>

<!-- Error Locations Card -->
<div class="card errores">
    <div class="card-value" id="errores-value">--</div>
    <div class="card-label">Ubicaciones con Error</div>
    <div class="card-loading hidden">
        <div class="card-loader"></div>
    </div>
</div>

<!-- Low Pallets Card -->
<div class="card menos-pallets">
    <div class="card-value" id="pallets-bajos-value">--</div>
    <div class="card-label">Ubicaciones con menos de 10 pallets</div>
    <div class="card-loading hidden">
        <div class="card-loader"></div>
    </div>
</div>

<!-- Retained Pallets Card -->
<div class="card retenidos">
    <div class="card-value" id="retenidos-value">--</div>
    <div class="card-label">Pallets retenidos</div>
    <div style="font-size: 0.8em; color: #666" id="retenidos-lineas">-- Líneas</div>
    <div class="card-loading hidden">
        <div class="card-loader"></div>
    </div>
</div>

<script>
// Variables globales para las estadísticas
let statsData = {
    utilizacion: 0,
    errores: 0,
    palletsBajos: 0,
    retenidos: 0,
    lineasRetenidas: 0
};

// Función para actualizar las estadísticas
function actualizarEstadisticas(datos) {
    if (!datos) return;
    
    try {
        // Actualizar datos
        statsData = {
            utilizacion: datos.utilizacion || 0,
            errores: datos.errores || 0,
            palletsBajos: datos.palletsBajos || 0,
            retenidos: datos.retenidos || 0,
            lineasRetenidas: datos.lineasRetenidas || 0
        };
        
        // Actualizar UI
        actualizarUIEstadisticas();
        
        // Ocultar loaders
        document.querySelectorAll('.card-loading').forEach(loader => {
            loader.classList.add('hidden');
        });
        
    } catch (error) {
        console.error('Error al actualizar estadísticas:', error);
    }
}

// Función para actualizar la UI
function actualizarUIEstadisticas() {
    // Utilización con círculo de progreso
    const utilizacionEl = document.getElementById('utilizacion-percentage');
    if (utilizacionEl) {
        const porcentaje = Math.round(statsData.utilizacion);
        utilizacionEl.textContent = `${porcentaje}%`;
        
        // Actualizar el círculo de progreso
        const circle = utilizacionEl.closest('.percentage-circle');
        if (circle) {
            const grados = Math.round((porcentaje / 100) * 360);
            circle.style.background = `conic-gradient(#ff6b35 0deg ${grados}deg, #e9ecef ${grados}deg 360deg)`;
        }
    }
    
    // Errores
    const erroresEl = document.getElementById('errores-value');
    if (erroresEl) {
        erroresEl.textContent = Utils.formatNumber(statsData.errores);
    }
    
    // Pallets bajos
    const palletsBajosEl = document.getElementById('pallets-bajos-value');
    if (palletsBajosEl) {
        palletsBajosEl.textContent = Utils.formatNumber(statsData.palletsBajos);
    }
    
    // Retenidos
    const retenidosEl = document.getElementById('retenidos-value');
    if (retenidosEl) {
        retenidosEl.textContent = Utils.formatNumber(statsData.retenidos);
    }
    
    // Líneas retenidas
    const lineasEl = document.getElementById('retenidos-lineas');
    if (lineasEl) {
        lineasEl.textContent = `${Utils.formatNumber(statsData.lineasRetenidas)} Líneas`;
    }
}

// Función para mostrar loaders
function mostrarLoadersEstadisticas() {
    document.querySelectorAll('.card-loading').forEach(loader => {
        loader.classList.remove('hidden');
    });
}

// Función para calcular estadísticas desde datos de inventario
function calcularEstadisticasDesdeInventario(inventarioData) {
    if (!inventarioData || !Array.isArray(inventarioData)) {
        return {
            utilizacion: 0,
            errores: 0,
            palletsBajos: 0,
            retenidos: 0,
            lineasRetenidas: 0
        };
    }
    
    try {
        let totalUbicaciones = 0;
        let ubicacionesOcupadas = 0;
        let errores = 0;
        let palletsBajos = 0;
        let retenidos = 0;
        let lineasRetenidas = 0;
        
        inventarioData.forEach(fila => {
            if (!fila || fila.length < 5) return;
            
            totalUbicaciones++;
            
            const cantidad = parseFloat(fila[6]) || 0; // Columna cantidad
            const ubicacion = fila[2] || ''; // Columna ubicación
            
            // Ubicaciones ocupadas
            if (cantidad > 0) {
                ubicacionesOcupadas++;
            }
            
            // Errores (ubicaciones con datos inconsistentes)
            if (ubicacion && (isNaN(cantidad) || cantidad < 0)) {
                errores++;
            }
            
            // Pallets bajos (menos de 10)
            if (cantidad > 0 && cantidad < 10) {
                palletsBajos++;
            }
            
            // Retenidos (ejemplo: productos vencidos o con problemas)
            const diasVencimiento = parseInt(fila[12]) || 0; // Columna días hasta caducidad
            if (diasVencimiento < 0) {
                retenidos += cantidad;
                lineasRetenidas++;
            }
        });
        
        const utilizacion = totalUbicaciones > 0 ? (ubicacionesOcupadas / totalUbicaciones) * 100 : 0;
        
        return {
            utilizacion,
            errores,
            palletsBajos,
            retenidos,
            lineasRetenidas
        };
        
    } catch (error) {
        console.error('Error al calcular estadísticas:', error);
        return {
            utilizacion: 0,
            errores: 0,
            palletsBajos: 0,
            retenidos: 0,
            lineasRetenidas: 0
        };
    }
}

// Función para animar los valores
function animarValoresEstadisticas() {
    const duration = 1000; // 1 segundo
    const steps = 30;
    const stepDuration = duration / steps;
    
    const elements = [
        { el: document.getElementById('utilizacion-percentage'), target: statsData.utilizacion, suffix: '%' },
        { el: document.getElementById('errores-value'), target: statsData.errores, suffix: '' },
        { el: document.getElementById('pallets-bajos-value'), target: statsData.palletsBajos, suffix: '' },
        { el: document.getElementById('retenidos-value'), target: statsData.retenidos, suffix: '' }
    ];
    
    elements.forEach(({ el, target, suffix }) => {
        if (!el) return;
        
        let current = 0;
        const increment = target / steps;
        
        const interval = setInterval(() => {
            current += increment;
            if (current >= target) {
                current = target;
                clearInterval(interval);
            }
            
            if (suffix === '%') {
                el.textContent = `${Math.round(current)}${suffix}`;
                // Actualizar círculo de progreso
                const circle = el.closest('.percentage-circle');
                if (circle) {
                    const grados = Math.round((current / 100) * 360);
                    circle.style.background = `conic-gradient(#ff6b35 0deg ${grados}deg, #e9ecef ${grados}deg 360deg)`;
                }
            } else {
                el.textContent = Utils.formatNumber(Math.round(current));
            }
        }, stepDuration);
    });
}

// Inicialización
document.addEventListener('DOMContentLoaded', function() {
    // Mostrar loaders inicialmente
    mostrarLoadersEstadisticas();
    
    // Exponer funciones globalmente
    window.actualizarEstadisticas = actualizarEstadisticas;
    window.calcularEstadisticasDesdeInventario = calcularEstadisticasDesdeInventario;
    window.mostrarLoadersEstadisticas = mostrarLoadersEstadisticas;
    window.animarValoresEstadisticas = animarValoresEstadisticas;
});
</script>
=======
<script>
  function actualizarDashboardCards(forzarActualizacion) {
    if (window.evitarActualizacionStats && !forzarActualizacion) {
      console.log("Actualización de stats evitada durante cambio de mapa");
      return;
    }

    // Verificar que tenemos los datos de productos desde el archivo subido
    if (
      !window.datosProductos ||
      Object.keys(window.datosProductos).length === 0
    ) {
      console.log(
        "No hay datos de productos disponibles para actualizar los cards"
      );
      // Mostrar indicadores de carga en todos los cards
      document
        .querySelectorAll(".card .chart-container, .card .card-content")
        .forEach((container) => {
          container.style.display = "none";
        });
      document.querySelectorAll(".card .card-loading").forEach((loader) => {
        loader.style.display = "flex";
      });

      return;
    }

    // Ocultar todos los indicadores de carga
    document.querySelectorAll(".card .card-loading").forEach((loader) => {
      loader.style.display = "none";
    });
    document
      .querySelectorAll(".card .chart-container, .card .card-content")
      .forEach((container) => {
        container.style.display = "block";
      });

    try {
      // Inicializar variables para conteo
      let totalUtilizado = 0;
      let totalCapacidad = 0;

      // Contar ubicaciones con error
      let ubicacionesConError = 0;

      // Ubicaciones con menos de 10 pallets
      const stockThresholdInput = document.getElementById("stockThreshold");

      if (stockThresholdInput && !stockThresholdInput.hasEventListener) {
        stockThresholdInput.hasEventListener = true;
        stockThresholdInput.addEventListener("change", function () {
          actualizarDashboardCards(true);
        });
      }

      const umbralBajoPallet = stockThresholdInput
        ? parseInt(stockThresholdInput.value) || 10
        : 10;
      let ubicacionesConBajoPallet = 0;
      const ubicacionesConBajoPalletSet = new Set();

      // Productos en retenido
      let productosRetenido = 0;
      let productosRetenidoLineas = 0;

      // Mapeo de ubicaciones por área para todas las áreas
      const ubicacionesPorArea = {};

      // Contar pallets por ubicación para todas las ubicaciones
      const palletsPorUbicacion = {};

      // Procesar todos los productos para obtener conteo completo
      Object.entries(window.datosProductos).forEach(([sku, producto]) => {
        if (producto.ubicaciones && Array.isArray(producto.ubicaciones)) {
          producto.ubicaciones.forEach((ubicacion) => {
            const ubicacionId = ubicacion.ubicacion;
            const cantidad = ubicacion.cantidad || 0;

            // Acumular pallets por ubicación
            if (!palletsPorUbicacion[ubicacionId]) {
              palletsPorUbicacion[ubicacionId] = 0;
            }
            palletsPorUbicacion[ubicacionId] += cantidad;

            // Verificar si es área de retenido
            if (
              ubicacionId.toUpperCase() === "RETENIDO" ||
              (/\bRETENIDO\b/.test(ubicacionId.toUpperCase()) &&
                !ubicacionId.toUpperCase().includes("RETENIDO LINEAS"))
            ) {
              productosRetenido += cantidad;
            }

            // Para RETENIDO LINEAS
            if (ubicacionId.toUpperCase().includes("RETENIDO LINEAS")) {
              productosRetenidoLineas += cantidad;
            }

            // Obtener área de la ubicación desde el mapa
            let area = "";
            const elementoUbicacion = document.querySelector(
              `g[data-ubicacion="${ubicacionId}"]`
            );
            if (elementoUbicacion) {
              area = elementoUbicacion.getAttribute("data-area") || "";
            }

            // Si tenemos datosUbicaciones, usarlo como respaldo
            if ((!area || area === "") && datosUbicaciones) {
              const tipoMapa =
                document.getElementById("tipoMapaSelector")?.value ||
                "ocupacion";
              const datosMapa = datosUbicaciones[tipoMapa] || {};
              if (datosMapa[ubicacionId]) {
                area = datosMapa[ubicacionId].area || "";
              }
            }

            // Registrar ubicación en su área
            if (area !== "") {
              if (!ubicacionesPorArea[area]) {
                ubicacionesPorArea[area] = [];
              }
              // Evitar duplicados (mismo ubicacionId en el mismo área)
              if (!ubicacionesPorArea[area].some((u) => u.id === ubicacionId)) {
                ubicacionesPorArea[area].push({
                  id: ubicacionId,
                  utilizado: 0, // Se actualizará después
                  capacidad_maxima: 0, // Se actualizará después
                });
              }
            }
          });
        }
      });

      // Obtener capacidad máxima de ubicaciones desde datosUbicaciones si está disponible
      if (datosUbicaciones) {
        const tipoMapa =
          document.getElementById("tipoMapaSelector")?.value || "ocupacion";
        const datosMapa = datosUbicaciones[tipoMapa] || {};

        Object.entries(datosMapa).forEach(([id, dato]) => {
          // Si encontramos información de capacidad, actualizar en nuestro registro
          for (const area in ubicacionesPorArea) {
            const ubicacion = ubicacionesPorArea[area].find((u) => u.id === id);
            if (ubicacion) {
              ubicacion.capacidad_maxima = dato.capacidad_maxima || 0;
              // También actualizar utilizado con datos reales si está disponible
              ubicacion.utilizado = dato.utilizado || 0;
            }
          }
        });
      }

      // Actualizar el conteo de pallets utilizando los datos recopilados
      for (const area in ubicacionesPorArea) {
        ubicacionesPorArea[area].forEach((ubicacion) => {
          // Si no tenemos datos de utilización, usar los pallets contados
          if (ubicacion.utilizado === 0 && palletsPorUbicacion[ubicacion.id]) {
            ubicacion.utilizado = palletsPorUbicacion[ubicacion.id];
          }
        });
      }

      // Ahora procesar solo las áreas consideradas para las estadísticas
      AREAS_CONSIDERADAS.forEach((area) => {
        if (ubicacionesPorArea[area]) {
          ubicacionesPorArea[area].forEach((ubicacion) => {
            totalUtilizado += ubicacion.utilizado;
            totalCapacidad += ubicacion.capacidad_maxima;

            // Detectar ubicaciones con error (más utilizadas que su capacidad)
            if (
              ubicacion.capacidad_maxima > 0 &&
              ubicacion.utilizado > ubicacion.capacidad_maxima
            ) {
              ubicacionesConError++;
            }

            // Contar ubicaciones con menos de 10 pallets que no sean rack
            const pasillo = ubicacion.id.slice(0, 3);
            if (
              !PASILLO_RACK.includes(pasillo) &&
              ubicacion.utilizado > 0 &&
              ubicacion.utilizado < umbralBajoPallet
            ) {
              console.log(ubicacion.id);
              ubicacionesConBajoPalletSet.add(ubicacion.id);
            }
          });
        }
      });

      // Contar las ubicaciones con menos de 10 pallets
      ubicacionesConBajoPallet = ubicacionesConBajoPalletSet.size;

      // Calcular porcentaje de utilización
      const porcentajeUtilizacion =
        totalCapacidad > 0
          ? ((totalUtilizado / totalCapacidad) * 100).toFixed(1)
          : 0;

      // Actualizar valores en los cards con verificaciones
      const utilizacionElement = document.querySelector(
        ".card:nth-child(1) .card-value"
      );
      const erroresElement = document.querySelector(
        ".card:nth-child(2) .card-value"
      );
      const bajoPalletElement = document.querySelector(
        ".card:nth-child(3) .card-value"
      );
      const cuartaCard = document.querySelector(".card:nth-child(4)");
      const retenidoElements = cuartaCard
        ? cuartaCard.querySelectorAll(".card-value")
        : [];

      if (utilizacionElement)
        utilizacionElement.textContent = `${porcentajeUtilizacion}%`;
      if (erroresElement) erroresElement.textContent = ubicacionesConError;
      if (bajoPalletElement)
        bajoPalletElement.textContent = ubicacionesConBajoPallet;
      if (retenidoElements && retenidoElements.length >= 2) {
        retenidoElements[0].textContent = productosRetenido;
        retenidoElements[1].textContent = productosRetenidoLineas;
      }

      // Actualizar también la descripción para que indique que son áreas filtradas
      const utilizacionLabel = document.querySelector(
        ".card:nth-child(1) .card-label"
      );
      if (utilizacionLabel) {
        utilizacionLabel.textContent = `(Solo áreas: ${AREAS_CONSIDERADAS.join(
          ", "
        )})`;
      }

      // Cambiar el texto del label para el card de bajo pallet
      const bajoPalletLabel = document.querySelector(
        ".card:nth-child(3) .card-label"
      );
      if (bajoPalletLabel) {
        bajoPalletLabel.textContent = "Ubicaciones con < 10 pallets";
      }

      // Crear gráfico de utilización si existe Chart.js
      if (typeof Chart !== "undefined") {
        crearGraficoUtilizacion(porcentajeUtilizacion);
      }

      console.log(
        `Dashboard actualizado: ${porcentajeUtilizacion}% utilización en áreas consideradas`
      );
    } catch (error) {
      console.error("Error al actualizar dashboard cards:", error);
    }
  }

  function crearGraficoUtilizacion(porcentaje) {
    const ctx = document.getElementById("utilizacionChart");
    if (!ctx) {
      console.warn("Elemento del gráfico no encontrado");
      return;
    }

    try {
      // Verificar si el gráfico es una instancia válida de Chart antes de intentar destruirlo
      if (window.utilizacionChart instanceof Chart) {
        window.utilizacionChart.destroy();
      } else if (window.utilizacionChart) {
        // Si existe pero no es una instancia de Chart, simplemente resetéalo
        window.utilizacionChart = null;
      }

      // Determinar el color según el porcentaje
      let color = "#00FF00"; // Verde para bajo uso
      if (porcentaje > 75) {
        color = "#FF0000"; // Rojo para alto uso
      } else if (porcentaje > 50) {
        color = "#FF7700"; // Naranja para uso medio
      } else if (porcentaje > 25) {
        color = "#FFFF00"; // Amarillo para uso bajo-medio
      }

      // Asegúrate de que Chart está disponible antes de crear un nuevo gráfico
      if (typeof Chart === "undefined") {
        console.warn("Chart.js no está disponible");
        return;
      }

      // Crear un nuevo gráfico con plugin para mostrar texto en el centro
      window.utilizacionChart = new Chart(ctx, {
        type: "doughnut",
        data: {
          labels: ["Utilizado", "Libre"],
          datasets: [
            {
              data: [porcentaje, 100 - porcentaje],
              backgroundColor: [color, "#e0e0e0"],
              borderWidth: 0,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutout: "70%",
          plugins: {
            legend: {
              display: false,
            },
            tooltip: {
              enabled: false,
            },
            // Añadir este plugin personalizado para mostrar el texto en el centro
            doughnutCenterText: {
              text: `${porcentaje}%`,
              color: "#333333",
              fontStyle: "bold",
              sidePadding: 20,
            },
          },
        },
        plugins: [
          {
            id: "doughnutCenterText",
            beforeDraw: function (chart) {
              if (chart.config.options.plugins.doughnutCenterText) {
                // Obtener config
                var config = chart.config.options.plugins.doughnutCenterText;

                // Obtener el contexto de dibujo y calcular posición central
                var ctx = chart.ctx;
                var centerX =
                  chart.chartArea.left +
                  (chart.chartArea.right - chart.chartArea.left) / 2;
                var centerY =
                  chart.chartArea.top +
                  (chart.chartArea.bottom - chart.chartArea.top) / 2;

                // Guardar estado del contexto
                ctx.save();

                // Configurar el texto
                var fontSize =
                  (chart.chartArea.right - chart.chartArea.left) / 12; // Ajustar tamaño basado en ancho
                if (fontSize < 20) fontSize = 20; // Mínimo tamaño
                if (fontSize > 35) fontSize = 35; // Máximo tamaño

                ctx.font = fontSize + "px Arial, sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = config.color || "#333333";

                // Dibujar el texto
                ctx.fillText(config.text, centerX, centerY);

                // Restaurar el contexto
                ctx.restore();
              }
            },
          },
        ],
      });
    } catch (error) {
      console.error("Error al crear gráfico de utilización:", error);
      // En caso de error, asegurarse de que no quede un gráfico parcialmente inicializado
      window.utilizacionChart = null;
    }
  }
</script>
>>>>>>> 50c62eb1b443212dff1e0d4c959c6a6b060a1ef9
